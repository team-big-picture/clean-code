---
sidebar_position: 1
---

# 6장 객체와 자료구조

> 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.
> 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.

## 자료 추상화

> 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다!
> 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.

```java
// 구체적인 Vehicle 클래스
 public interface Vehicle {
  double getFuelTankCapacityInGallons();
  double getGallonsOfGasoline();
 }
```

```java
// 추상적인 Vehicle 클래스
 public interface Vehicle {
  double getPercentFuelRemaining();
 }
```

위 코드 중 `추상적인 Vehicle 클래스`처럼 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 더 좋다.

> 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다. 아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.

## 자료/객체 비대칭

> 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
> 반대쪽도 참이다.
> 다시 말해, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다!

복잡한 시스템에서 분별있는 프로그래머가 되려면, 새로운 자료타입이 필요한지 아니면 새로운 함수가 필요한 경우인지, 상황에 맞는 더 적합한 코드를 생각해야 할 필요가 있다.

## 디미터 법칙

> 디미터 법칙은 잘 알려진 휴리스틱으로 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.

### 기차충돌

```java
final String outPutDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

흔히 위와 같은 코드를 기차 충동이라 부른다.
여러 객차가 한 줄로 이어진 기차처럼 보이기 때문이다. 일반적으로 이러한 방식은 조잡하다 여겨지므로 피하는 편이 좋다.

```java
  Options opts = ctxt.getOptions();
  File scratchDir = opts.getScratchDir();
  final String outputDir = scratchDir.getAbsolutePath();
```

위 코드는 다음과 같이 나누는 편이 좋다.
그런데 위 예제는 조회 함수를 사용하는 바람에 혼란을 일으킨다. 코드를 다음과 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다.

```java
  final String outputDir = ctxt.options.scratchDir.absolutePath;
```

> 스터티 코멘트

- 메소드의 역할을 분리하자! (메소드체이닝을 지양하자)

### 잡종 구조

> 이런 혼란으로 말미암아 때때로 절반은 객체, 절반은 자료구조인 잡종 구조가 나온다.
> 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. 그러므로 잡종 구조는 되도록 피하는 편이 좋다.
> 프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해(더 나쁘게는 무지해) 어중간하게 내놓은 설계에 불과하다.

### 구조체 감추기

위의 예시 코드에서 임시 디렉터리의 절대 경로를 얻으려는 이유는 임시 파일을 생성하기 위한 목적이다.
그렇다면 다음과 같이 작성해보자.

```java
  BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);
```

> ctxt는 내부 구조를 드러내지 않으며, 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않는다.

## 자료 전달 객체

> 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(DTO)라 한다.
> 흔히 DTO는 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체다.

### 활성 레코드

> 활성 레코드는 DTO의 특수한 형태다.
> 불행히도 활성 레코드에 비즈니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하다.
> 하지만 이는 바람직하지 않다. 그러면 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오기 때문이다.

> 해결책은 당연하다. 활성 레코드는 자료 구조로 취급한다. 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.
